---
title: "2. Cross-tabulation"
output: md_document
---
# Creating a cross-tablulation
```{r opts, include=FALSE}
knitr::opts_chunk$set(tidy = FALSE)
```
## Using Basic Recoding

The next step is to add additional variables to the tabulations that we went through in the first tutorial.  This tutorial should be much shorter now that the basics are out of the way.  We'll continue using the poverty_new variable that we created.  The code to load the libraries and data, then recode the variable is below.

```{r warning=FALSE, message=FALSE, setup}
library(car)
library(dplyr)

# Change the file path to the proper location

# setwd(PATH_TO_TUTORIAL_FOLDER) #uncomment this line to change directory.

# reads in the csv file and stores it. stringsAsFactors=FALSE keeps R from transforming variables you don't want transformed.

data <- read.csv("Data and Documentation/ss14pco.csv", stringsAsFactors=FALSE) 

data <- data%>% # passes the data object we created above to the next function
          mutate(poverty_new=recode(POVPIP, "000:124=1; 125:183=2; 183:501=3")) # adds the poverty_new variable to the end of the dataset, it doesn't over write POVPIP.

```

Let's say that we want to know about children and poverty using the same poverty levels we used before.  We'd need to create another variable, based on the `AGEP` variable (see the data dictionary page 32) that indicated if a person was under 18 or not. To do this, we'll use the base R command `ifelse` to create a statement that will make those under 18 coded to 1 and those 18 and over coded 2. 

```{r, recode}

data <- data%>%
  mutate(child=ifelse(AGEP<18, 1, 2))
```


While I just used this approach, it is always worthwhile to check on missing variables before moving forward as they would be coded 2 here.  AGEP doesn't have any missing variables (as shown by the code below) so we don't have to worry. We can chain two `ifelse` statements together to deal with this if it becomes and issue.  You can choose to give the missing data a real code or to just keep it missing.  I've provided and example below.

```{r, missing}

# to determine if there are missing variables add exclude=NULL to table()
table(data$AGEP, exclude=NULL)

# We can eliminate NA being coded by explicitly telling the code to deal with them on their own.
# This variable is identical to the child variable because AGEP has no missing values.
# is.na() is used to identify missing values in the data.

data <- data%>%
          mutate(child_wMissing=ifelse(is.na(AGEP), NA,
                                       ifelse(AGEP<18, 1, 2)))
# This line tests if the two variables are equivalent, is will print TRUE if they are.

identical(data$child, data$child_wMissing)

```


We've now added the additional variable we need to the data set we can create the cross tabulation. Essentially, a cross tabulation is taking one basic tabulation and finding out how the values within each category would be broken up within other categories.  To do this practically, the `group_by` function is of great use.  We can just add our new variable to the call we used before.  This tells R that rather than just grouping by the `poverty_new` variable, group by that first then also group by our `child` variable within that first grouping.  In this case ordering isn't important because the output is going to show us the unique intersections of each category for each variable.  Basically the output is taking a cross-tab table and turning each cell into a row.

```{r, crosstab}

children_poverty <- data%>%
  group_by(poverty_new, child)%>%
  summarize(total=sum(PWGTP))

children_poverty
```

## Label Recoded Variables

In our previous example we needed to remember or refer to which category recieved which code.  In this demonstration, I'll add labels so we are able to more quickly derive insights.

R has a specific type of variable that is useful for many operations, but I use it the most for labeling recoded variables.  This variable type is called a factor.  It contains two pieces of information, a level (numeric but doesn't need to indicate ordering even though it can) and a label for that level.  There are ordered and unordered factors, but I'll be using an ordered factor for both since each variable has an intrinsic ordering.

Quick side note, you can ignore this if you'd like.  R also has a text variable called a "string" that I could just use in the recode calls directly.  It would make the actual values for each recode into their labels rather than the numeric values I used.  I don't necessarily think that this approach is wrong, but it is certainly less flexible.  Particularly if you'd like to graph the data.  I can control the ordering of the labels by assigning the level in the order I'd like them displayed using factors, I can't do this on strings, which use an alphabetical sorting method.  I can also always pull the text out of the factor labels if needed.

Techincally, this next bit of code will take the variables we already made and use them to create new variables as factors with labels.  I'll use the function `ordered` to create the factor since I'm implying an order to the levels, but if your data are not ordered and you don't mind an alphabethical sort, `factor` will work as well. A couple more technical notes: `:` in R means through, so `1:3` means use values 1 through 3 and the `c()` command concatenates whatever you put into the parenthese into a vector of values.  R uses that a TON within functions to help keep things orderly.

```{r, labels}

# adding the new labeled variables.
data <- data%>%
          mutate(poverty_labels=ordered(poverty_new, levels=1:3, labels =
                                          c("Less than 125%", "125% to 183%", "More than 183%")),
                 child_labels= ordered(child, levels=1:2, labels = 
                                         c("Child", "Adult")))
# Creating a new object to store the labeled table
children_poverty_labels <- data%>%
  group_by(poverty_labels, child_labels)%>%
  summarize(total=sum(PWGTP))

# tests that the results are numerically identical
identical(children_poverty$total, children_poverty_labels$total)

# prints out the new table
children_poverty_labels


```

## Exporting Results

It's nice to be able to generate these tables and output them in R, but regardless of where you work or what you do you'll need to export them to other programs.  R supports exporting data to CSV files natively and that is the method I'll be using here.  There are also a very strong set of packages to export and format data for Excel specifically, but those are beyond the scope of this tutorial.  Check out the `xlsx` package as a good place to start, but there are many others, that's just the one I use most of the time.

The following code uses the base R function `write.csv` to export the tables into their own CSV files that can be read in any spreadsheet program.

```{r eval=FALSE, output}

# Specify the name of the file to write to first, then the object to write.
# row.names = FALSE is set to prevent R from writing a column of values out with the row number in the final output.
write.csv("children_poverty_labels.csv", children_poverty_labels, row.names = FALSE)

```


